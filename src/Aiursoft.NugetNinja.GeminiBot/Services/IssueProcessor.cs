using Aiursoft.CSTools.Services;
using Aiursoft.GitRunner;
using Aiursoft.GitRunner.Models;
using Aiursoft.NugetNinja.GeminiBot.Configuration;
using Aiursoft.NugetNinja.GeminiBot.Models;
using Aiursoft.NugetNinja.GitServerBase.Models;
using Aiursoft.NugetNinja.GitServerBase.Services.Providers;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Aiursoft.NugetNinja.GeminiBot.Services;

/// <summary>
/// Encapsulates the business logic for processing GitLab issues.
/// Provides a clean, testable interface for issue resolution workflow.
/// </summary>
public class IssueProcessor
{
    private readonly IVersionControlService _versionControl;
    private readonly WorkspaceManager _workspaceManager;
    private readonly CommandService _commandService;
    private readonly GeminiBotOptions _options;
    private readonly ILogger<IssueProcessor> _logger;

    public IssueProcessor(
        IVersionControlService versionControl,
        WorkspaceManager workspaceManager,
        CommandService commandService,
        IOptions<GeminiBotOptions> options,
        ILogger<IssueProcessor> logger)
    {
        _versionControl = versionControl;
        _workspaceManager = workspaceManager;
        _commandService = commandService;
        _options = options.Value;
        _logger = logger;
    }

    /// <summary>
    /// Processes an issue: validates, checks for existing PRs, clones repo, runs Gemini, and creates PR.
    /// </summary>
    public async Task<ProcessResult> ProcessAsync(Issue issue, Server server)
    {
        try
        {
            // Validation
            ValidateIssue(issue);

            // Check if issue already has an open PR/MR - using polymorphic interface method
            if (await _versionControl.HasOpenPullRequestForIssue(server.EndPoint, issue.ProjectId, issue.Iid, server.Token))
            {
                _logger.LogInformation("Issue #{IssueId} already has an open PR/MR. Skipping...", issue.Iid);
                return ProcessResult.Skipped("Issue already has an open PR/MR");
            }

            // Get repository details through interface - no GitLab-specific code!
            _logger.LogInformation("Fetching repository details for issue #{IssueId}...", issue.Iid);
            var repository = await _versionControl.GetRepository(server.EndPoint, issue.ProjectId.ToString(), string.Empty, server.Token);

            // Clone repository
            var workPath = GetWorkspacePath(issue, repository);
            _logger.LogInformation("Cloning repository for issue #{IssueId} to {WorkPath}...", issue.Iid, workPath);

            await _workspaceManager.ResetRepo(
                workPath,
                repository.DefaultBranch ?? throw new InvalidOperationException($"Repository default branch is null for issue {issue.Id}"),
                repository.CloneUrl ?? throw new InvalidOperationException($"Repository clone URL is null for issue {issue.Id}"),
                CloneMode.Full,
                $"{server.UserName}:{server.Token}");

            // Run Gemini CLI
            var taskDescription = BuildTaskDescription(issue);
            _logger.LogInformation("Invoking Gemini CLI to process issue #{IssueId}...", issue.Iid);

            var geminiSuccess = await InvokeGeminiCliAsync(workPath, taskDescription);
            if (!geminiSuccess)
            {
                return ProcessResult.Failed($"Gemini CLI failed to process issue #{issue.Iid}");
            }

            // Gemini CLI may take a while to finish.
            await Task.Delay(1000);

            // Check for changes
            if (!await _workspaceManager.PendingCommit(workPath))
            {
                _logger.LogInformation("Issue #{IssueId} - Gemini made no changes. Skipping...", issue.Iid);
                return ProcessResult.Skipped("No changes made");
            }

            // Commit changes
            _logger.LogInformation("Issue #{IssueId} has pending changes. Creating PR...", issue.Iid);
            await _workspaceManager.SetUserConfig(workPath, server.DisplayName, server.UserEmail);

            var commitMessage = $"Fix for issue #{issue.Iid}: {issue.Title}\n\nAutomatically generated by Gemini Bot.";
            var branchName = $"fix-issue-{issue.Iid}";

            var saved = await _workspaceManager.CommitToBranch(workPath, commitMessage, branchName);
            if (!saved)
            {
                return ProcessResult.Failed($"Failed to commit changes for issue #{issue.Iid}");
            }

            // Fork if needed and push
            await EnsureRepositoryForkedAsync(server, repository);

            var pushPath = _versionControl.GetPushPath(server, repository);
            await _workspaceManager.Push(workPath, branchName, pushPath, force: true);

            // Create PR if needed
            await CreatePullRequestIfNeededAsync(server, repository, issue, branchName);

            return ProcessResult.Succeeded($"Successfully processed issue #{issue.Iid}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing issue #{IssueId}", issue.Iid);
            return ProcessResult.Failed($"Error processing issue #{issue.Iid}", ex);
        }
    }

    private void ValidateIssue(Issue issue)
    {
        if (string.IsNullOrWhiteSpace(issue.Title))
        {
            throw new ArgumentException($"Issue {issue.Id} has no title", nameof(issue));
        }

        if (issue.ProjectId <= 0)
        {
            throw new ArgumentException($"Issue {issue.Id} has invalid project ID", nameof(issue));
        }
    }

    private string GetWorkspacePath(Issue issue, Repository repository)
    {
        var repoName = repository.Name ?? "unknown";
        return Path.Combine(_options.WorkspaceFolder, $"{issue.ProjectId}-{repoName}-issue-{issue.Iid}");
    }

    private string BuildTaskDescription(Issue issue)
    {
        return $"Issue #{issue.Iid}: {issue.Title}\n\n{issue.Description ?? "No description provided."}\n\nPlease analyze this issue and make the necessary code changes to resolve it.";
    }

    private async Task<bool> InvokeGeminiCliAsync(string workPath, string taskDescription)
    {
        string? tempFile = null;
        var gitPath = Path.Combine(workPath, ".git");
        var gitBackupPath = workPath + "-hidden-git";


        try
        {
            // Write task to temp file
            tempFile = Path.Combine(workPath, ".gemini-task.txt");
            await File.WriteAllTextAsync(tempFile, taskDescription);

            // Hide .git directory to prevent Gemini from manipulating git
            if (Directory.Exists(gitPath))
            {
                _logger.LogInformation("Hiding .git directory to prevent Gemini CLI from manipulating git...");
                Directory.Move(gitPath, gitBackupPath);
            }

            _logger.LogInformation("Running Gemini CLI in {WorkPath}", workPath);

            // Build Gemini command with optional --model parameter
            var geminiCommand = "gemini --yolo";
            if (!string.IsNullOrWhiteSpace(_options.Model))
            {
                geminiCommand += $" --model {_options.Model}";
            }
            geminiCommand += " < .gemini-task.txt";

            // Build environment variables dictionary
            IDictionary<string, string?>? envVars = null;
            if (!string.IsNullOrWhiteSpace(_options.GeminiApiKey))
            {
                envVars = new Dictionary<string, string?>
                {
                    ["GEMINI_API_KEY"] = _options.GeminiApiKey
                };
            }

            var (code, output, error) = await _commandService.RunCommandAsync(
                bin: "/bin/bash",
                arg: $"-c \"{geminiCommand}\"",
                path: workPath,
                timeout: _options.GeminiTimeout,
                environmentVariables: envVars);

            if (code != 0)
            {
                _logger.LogError("Gemini CLI failed with exit code {Code}. Output: {Output}. Error: {Error}", code, output, error);
                return false;
            }

            _logger.LogInformation("Gemini CLI completed successfully. It says: {Output}", output);
            return true;
        }
        finally
        {
            // Restore .git directory
            if (Directory.Exists(gitBackupPath))
            {
                try
                {
                    _logger.LogInformation("Restoring .git directory...");
                    if (Directory.Exists(gitPath))
                    {
                        Directory.Delete(gitPath, recursive: true);
                    }
                    Directory.Move(gitBackupPath, gitPath);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to restore .git directory from backup!");
                }
            }

            // Clean up temp file - proper error handling
            if (tempFile != null && File.Exists(tempFile))
            {
                try
                {
                    File.Delete(tempFile);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to delete temporary file: {FilePath}", tempFile);
                }
            }
        }
    }

    private async Task EnsureRepositoryForkedAsync(Server server, Repository repository)
    {
        var ownerLogin = repository.Owner?.Login ?? throw new InvalidOperationException("Repository owner is null");
        var repoName = repository.Name ?? throw new InvalidOperationException("Repository name is null");

        if (!await _versionControl.RepoExists(server.EndPoint, server.UserName, repoName, server.Token))
        {
            _logger.LogInformation("Forking repository {Org}/{Repo}...", ownerLogin, repoName);
            await _versionControl.ForkRepo(server.EndPoint, ownerLogin, repoName, server.Token);

            // Wait for fork to complete
            await Task.Delay(_options.ForkWaitDelayMs);

            while (!await _versionControl.RepoExists(server.EndPoint, server.UserName, repoName, server.Token))
            {
                _logger.LogInformation("Waiting for fork to complete...");
                await Task.Delay(_options.ForkWaitDelayMs);
            }
        }
    }

    private async Task CreatePullRequestIfNeededAsync(Server server, Repository repository, Issue issue, string branchName)
    {
        var ownerLogin = repository.Owner?.Login ?? throw new InvalidOperationException("Repository owner is null");
        var repoName = repository.Name ?? throw new InvalidOperationException("Repository name is null");
        var defaultBranch = repository.DefaultBranch ?? throw new InvalidOperationException("Repository default branch is null");

        var existingPullRequestsByBot = (await _versionControl.GetPullRequests(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                server.Token))
            .Where(p => string.Equals(p.User?.Login, server.UserName, StringComparison.OrdinalIgnoreCase));

        if (existingPullRequestsByBot.All(p => p.State != "open"))
        {
            _logger.LogInformation("Creating pull request for issue #{IssueId}...", issue.Iid);

            var title = $"Fix for issue #{issue.Iid}: {issue.Title}";
            var body = $@"
Automatically generated by Gemini Bot to fix issue #{issue.Iid}.

Closes #{issue.Iid}

## Issue
{issue.Title}

{issue.Description ?? "No description provided."}

## Changes
This pull request contains automated fixes generated by the Gemini Bot.

Please review carefully before merging.";

            await _versionControl.CreatePullRequest(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                defaultBranch,
                title,
                body,
                server.Token);
        }
        else
        {
            _logger.LogInformation("Skipped creating new pull request for issue #{IssueId} because one already exists", issue.Iid);
        }
    }
}
