using System.Net.Http.Json;
using System.Text.Json;
using Aiursoft.NugetNinja.PrBot;
using Microsoft.Extensions.Logging;

public class GitLabService : IVersionControlService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<GitLabService> _logger;

    public GitLabService(HttpClient httpClient, ILogger<GitLabService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public string GetName() => "GitLab";

    public async Task<bool> RepoExists(string endPoint, string orgName, string repoName, string patToken)
    {
        _logger.LogInformation($"Checking if repository exists in GitLab: {orgName}/{repoName}...");
        try
        {
            var endpoint = $"{endPoint}/api/v4/projects/{orgName}%2F{repoName}";
            await SendHttp(endpoint, HttpMethod.Get, patToken);
            return true;
        }
        catch
        {
            return false;
        }
    }

    public async IAsyncEnumerable<Repository> GetMyStars(string endPoint, string userName, string patToken)
    {
        _logger.LogInformation($"Listing all starred repositories for user: {userName} in GitLab...");
        for (var i = 1; ; i++)
        {
            var endpoint = $"{endPoint}/api/v4/users/{userName}/starred_projects?per_page=100&page={i}";
            var currentPageItems = await SendHttpAndGetJson<List<Repository>>(endpoint, HttpMethod.Get, patToken);
            if (!currentPageItems.Any()) yield break;

            foreach (var repo in currentPageItems) yield return repo;
        }
    }

    public async Task ForkRepo(string endPoint, string org, string repo, string patToken)
    {
        _logger.LogInformation($"Forking repository in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{org}%2F{repo}/fork";
        await SendHttp(endpoint, HttpMethod.Post, patToken);
    }

    public async Task<List<PullRequest>> GetPullRequests(string endPoint, string org, string repo, string head, string patToken)
    {
        _logger.LogInformation($"Getting pull requests in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{org}%2F{repo}/merge_requests?state=opened&source_branch={head}";
        return await SendHttpAndGetJson<List<PullRequest>>(endpoint, HttpMethod.Get, patToken);
    }

    public async Task CreatePullRequest(string endPoint, string org, string repo, string head, string @base, string patToken)
    {
        _logger.LogInformation($"Creating a new pull request in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{org}%2F{repo}/merge_requests";
        await SendHttp(endpoint, HttpMethod.Post, patToken, new
        {
            title = "Auto dependencies upgrade by bot.",
            description = @"
Auto dependencies upgrade by bot. This is automatically generated by bot.

The bot tries to fetch all possible updates and modify the project files automatically.

This pull request may break or change the behavior of this application. Review with cautious!",
            source_branch = head,
            target_branch = @base
        });
    }

    public string GetPushPath(Server connectionConfiguration, Repository repo)
    {
        var pushPath = string.Format(connectionConfiguration.PushEndPoint,
                           $"{connectionConfiguration.UserName}:{connectionConfiguration.Token}")
                       + $"/{connectionConfiguration.UserName}/{repo.Name}.git";
        return pushPath;
    }

    public async Task<Repository> GetRepo(string endPoint, string orgName, string repoName, string patToken)
    {
        _logger.LogInformation($"Getting repository details in GitLab: {orgName}/{repoName}...");
        var endpoint = $"{endPoint}/api/v4/projects/{orgName}%2F{repoName}";
        return await SendHttpAndGetJson<Repository>(endpoint, HttpMethod.Get, patToken);
    }

    private async Task<string> SendHttp(string endPoint, HttpMethod method, string patToken, object? body = null)
    {
        var request = new HttpRequestMessage(method, endPoint)
        {
            Content = body != null
                ? JsonContent.Create(body)
                : null
        };

        request.Headers.Add("Authorization", $"Bearer {patToken}");
        request.Headers.Add("accept", "application/json");

        var response = await _httpClient.SendAsync(request);
        response.EnsureSuccessStatusCode();

        var json = await response.Content.ReadAsStringAsync();
        return json;
    }

    private async Task<T> SendHttpAndGetJson<T>(string endPoint, HttpMethod method, string patToken)
    {
        var json = await SendHttp(endPoint, method, patToken);
        var repos = JsonSerializer.Deserialize<T>(json) ??
                    throw new InvalidOperationException($"The remote server returned non-json content: '{json}'");
        return repos;
    }

    private Repository ConvertGitLabProjectToRepository(GitLabProject gitLabProject)
    {
        return new Repository
        {
            Id = gitLabProject.Id,
            Name = gitLabProject.Name,
            Owner = new User { Login = gitLabProject.Namespace.Name },
            Description = gitLabProject.Description,
            Url = gitLabProject.WebUrl
        };
    }
}

public class GitLabProject
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Path { get; set; }
    public string Description { get; set; }
    public string WebUrl { get; set; }
    public GitLabNamespace Namespace { get; set; }
}

public class GitLabNamespace
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Path { get; set; }
}
