using System.Text.Json.Serialization;
using Aiursoft.NugetNinja.PrBot;
using Microsoft.Extensions.Logging;

public class GitLabService : IVersionControlService
{
    private readonly HttpWrapper _httpClient;
    private readonly ILogger<GitLabService> _logger;

    public GitLabService(HttpWrapper httpClient, ILogger<GitLabService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public string GetName() => "GitLab";

    public async Task<bool> RepoExists(string endPoint, string orgName, string repoName, string patToken)
    {
        _logger.LogInformation($"Checking if repository exists in GitLab: {orgName}/{repoName}...");
        try
        {
            var endpoint = $"{endPoint}/api/v4/projects/{orgName}%2F{repoName}";
            await _httpClient.SendHttp(endpoint, HttpMethod.Get, patToken);
            return true;
        }
        catch
        {
            return false;
        }
    }

    public async IAsyncEnumerable<Repository> GetMyStars(string endPoint, string userName, string patToken)
    {
        _logger.LogInformation($"Listing all starred repositories for user: {userName} in GitLab...");
        for (var i = 1; ; i++)
        {
            var endpoint = $"{endPoint}/api/v4/users/{userName}/starred_projects?per_page=100&page={i}";
            var currentPageItems = await _httpClient.SendHttpAndGetJson<List<GitLabProject>>(endpoint, HttpMethod.Get, patToken);
            if (!currentPageItems.Any()) yield break;

            foreach (var repo in currentPageItems) yield return new Repository
            {
                Name = repo.Path,
                FullName = repo.PathWithNameSpace,
                Archived = repo.Archived,
                DefaultBranch = repo.DefaultBranch,
                CloneUrl = repo.HttpUrlToRepo,
                Owner = new User
                {
                    Login = repo.Namespace?.FullPath ?? throw new NullReferenceException("Got a GitLab repo with null namespace!")
                }
            };
        }
    }

    public async Task ForkRepo(string endPoint, string org, string repo, string patToken)
    {
        _logger.LogInformation($"Forking repository in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{org}%2F{repo}/fork";
        await _httpClient.SendHttp(endpoint, HttpMethod.Post, patToken);
    }

    public async Task<IEnumerable<PullRequest>> GetPullRequests(string endPoint, string org, string repo, string head, string patToken)
    {
        _logger.LogInformation($"Getting pull requests in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{org}%2F{repo}/merge_requests?state=opened&source_branch={head.Split(':').Last()}";
        var gitlabPrs = await _httpClient.SendHttpAndGetJson<List<GitLabPullRequest>>(endpoint, HttpMethod.Get, patToken);
        return gitlabPrs.Select(p => new PullRequest
        {
            User = new User
            {
                Login = p.Author?.UserName ?? throw new NullReferenceException("A pull request's author is null!")
            },
            State = p.State?.Replace("opened", "open")
        });
    }

    public async Task CreatePullRequest(string endPoint, string org, string repo, string head, string @base, string patToken)
    {
        var myName = head.Split(':').First();
        var myBranch = head.Split(":").Last();
        var project = await this.GetProject(endPoint, org, repo, patToken);
        _logger.LogInformation($"Creating a new pull request in GitLab: {org}/{repo}...");
        var endpoint = $"{endPoint}/api/v4/projects/{myName}%2F{repo}/merge_requests";
        await _httpClient.SendHttp(endpoint, HttpMethod.Post, patToken, new
        {
            title = "Auto dependencies upgrade by bot.",
            description = @"
Auto dependencies upgrade by bot. This is automatically generated by bot.

The bot tries to fetch all possible updates and modify the project files automatically.

This pull request may break or change the behavior of this application. Review with cautious!",
            source_branch = myBranch,
            target_branch = @base,
            target_project_id = project.Id
        });
    }

    private async Task<GitLabProject> GetProject(string endpoint, string org, string repo, string patToken)
    {
        //https://gitlab.aiursoft.cn/api/v4/projects/aiursoft%2fscanner
        return await _httpClient.SendHttpAndGetJson<GitLabProject>($"{endpoint}/api/v4/projects/{org}%2f{repo}", HttpMethod.Get, patToken);
    }

    public string GetPushPath(Server connectionConfiguration, Repository repo)
    {
        var pushPath = string.Format(connectionConfiguration.PushEndPoint,
                           $"{connectionConfiguration.UserName}:{connectionConfiguration.Token}")
                       + $"/{connectionConfiguration.UserName}/{repo.Name}.git";
        return pushPath;
    }
}

public class GitLabNamespace
{
    [JsonPropertyName("full_path")]
    public string? FullPath { get; set; }
}

public class GitLabProject
{
    [JsonPropertyName("id")]
    public int Id { get; set; }

    [JsonPropertyName("path")]
    public string? Path { get; set; }

    [JsonPropertyName("path_with_namespace")]
    public string? PathWithNameSpace { get; set; }

    [JsonPropertyName("http_url_to_repo")]
    public string? HttpUrlToRepo { get; set; }

    [JsonPropertyName("default_branch")]
    public string? DefaultBranch { get; set; }

    [JsonPropertyName("namespace")]
    public GitLabNamespace? Namespace { get; set; }

    [JsonPropertyName("archived")]
    public bool Archived { get; set; }
}

public class GitLabPullRequest
{
    [JsonPropertyName("author")]
    public GitLabUser? Author { get; set; }

    [JsonPropertyName("state")]
    public string? State { get; set; }
}

public class GitLabUser
{
    [JsonPropertyName("username")]
    public string? UserName { get; set; }
}